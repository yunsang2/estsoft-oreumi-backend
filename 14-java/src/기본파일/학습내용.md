Java 프로젝트

각 구성 단위의 명명 규칙
 유니코드 문자와 숫자, 밑줄 문자, 달러 기호를 조합하여 사용
 숫자로 시작할 수 없고 키워드를 사용할 수 없다
 대소문자를 구분한다


프로젝트
 하나의 애플리케이션을 작성하기 위한 단위
 공통 명명 규칙을 따르며, 파스칼 표기법으로 작성하는것이 관례이다


패키지
 클래스를 기능별로 묶어놓은 디렉토리
 패키지 안에 패키지가 들어갈 수 있고 해당 구분은 . 으로 한다
 다른 패키지 안에 있는 클래스를 쓰고 싶다면 import 명령문을 사용해 가져올 수 있다
 같은 패키지 안에 있다면 바로 사용할 수 있다
 패키지가 다르면 같은 클래스 식별자를 사용할 수 있다

클래스
 특정 대상을 표현하는 값과 그 값을 다루는 기능들의 집합
 Java 프로그램에서 실제로 작성되는 최하위 소스 파일
 일반적으로 하나의 클래스는 하나의 소스 파일에 작성하여, 파일이름은 클래스 이름과 같아야 한다
 파스칼 표기법으로 작성

변수, 메서드 
 소문자로 시작 두 번째 단어부터 첫글자는 대문자로 시작

기호상수
 상수는 모든 글자를 대문자로 한다

Java 프로그래밍 기초

    키워드
     프로그램에서 미리 정의된, 특별한 의미를 가진 단어

    식별자
     프로그램에서 이름을 붙일때 사용하는 단어
     변수명과 함수명이 식별자에 해당한다

    주석
     프로그램 실행에는 영향을 주지 않고 설명을 적기 위해 사용한다

    클래스
     객체를 생성하기 위한 자료형
     Java 프로그램은 객체들로 구성된다
     객체 = 필드 + 메서드
     public class day1_1 {
            
    main 메서드
     Java 프로그램에서 가장 먼저 실행되는 메서드
     일반적으로 main 메서드의 실행이 끝나면 프로그램의 실행도 끝난다
     
    메서드
     입력을 받아 작업을 수행하고 결과를 내보내는 프로그램 코드의 집합

        System.out 객체의 println 메서드
         출력과 동시에 마지막에 개행(\n)을 시켜주는 메서드


자료형, 변수, 상수
 
    자료형
     프로그램에서 다루는 값의 종류
        
        원시 자료형
         실제 값을 표현
         여러 자료형을 쓰는 이유는 변수마다 저장공간의 크기가 다르기때문에
            정수,실수,논리,문자
            
            문자 char

            정수 int, short, long, byte

            실수 double, float
            
            논리 boolean


        참조 자료형
         객체를 참조
            문자열,배열,클래스,인터페이스


    변수
     변하는 값
     값을 저장하기 위한 저장공간
     지정할 값을 "대입"을 통해 저장
     자료형을 먼저 지정하여 선언후 = 통해 대입
     대입과 동시에 초기화를 해주는것이 좋다


    상수
     변하지 않는 값
     "대입"을 통해 저장

    문자열
     Java 프로그램에서 문자열은 String 클래스의 인스턴스이다
     "" 로 대입한다
     두 문자열을 덧셈 연산 하면, 두 문자열을 연결해서 새로운 문자열을 생성한다



표현식과 연산자
    
    연산자
     연산자는 우선순위에 따라 연산순서가 정해진다
 
    표현식
     값을 만드러내는 프로그램 코드
     연산자와 피연산자로 이루워진다
     표현식은 항상 연산결과가 있다

    대입 연산자
     변수와 같은 저장공간에 값을 대입하는 연산자

    산술 연산자
     +,-,*,...
     산술 연산자는 차례재로 실행된다
    
    복합 대입 연산자
     +=, -=, *=...

    단항 연산자
     +num, -num , ++num, --num, num++, num--

    비교 연산자
     피연산자들의 자료형이 같아야 연산이 가능하다
     >, <, >=, <=
    
    논리 연산자
     !, &&, ||
     피연산자는 boolean자료형 이여야한다

    조건 연산자
     피연산자 ? 참일시 : 거짓일시
         


표준 입출력

    scanner 클래스
     java.till 패키지에 있는 입력 클래스
     문자 뿐만 아니라 정수, 실수, 문자열 등 다양한 자료형 값을 읽어 올수 있다
     입력된 값을 공백문자로 구분된 토큰 단위로 읽는다
     선언시 사용후엔 해제 해줘야 자원을 소모하지 않는다


제어문:조건문

    if 구문

    if-else 구문

    중첩 조건문

    if-else-if
    
    switch 구문


제어문:반복문

    while 구문

    do while 구문
    
    for 구문

제어문:중첩 반복문
 반복문 안에 다른 반복문이 들어간 형태
 안쪽과 바깥쪽의 인덱스 변수는 다르게 해야 한다
 2차원 구조를 표현할 수 있다
 이때 바깥쪽은 행, 안쪽은 열을 표현한다

 for (initial; condition; after-thought)
    for (initial; condition; after-thought)

제어문:반복문에서 실행 흐름 제어
    
    break 문
     switch 구문이나 반복문에서 break 문을 만나면 제어문을 빠져나간다
    
    continue 문
     반복문에서 continue 문을 만나면 현재 반복을 멈추고 다음 반복으로 진핸한다



알고리즘
 어떠한 문제를 해결하기위한 과정을 알고리즘이라 한다
 명령을 순차적으로 처리할때 효율적으로 해결하기 위해 사용
    알고리즘의 조건 5가지
     1. 입력
     2. 출력
     3. 열확성
     4. 유한성
     5. 효과성
 알고리즘은 시간, 공간 복잡도가 적으면 작을수록 효율적인 알고리즘이다



유클리드 알고리즘
 주 자연수 또는 정식의 최대 공약수를 구하는 알고리즘
 a 와 b 의 최대 공약수는 a 를 b 로 나눈 나머지를 r 이라하면 a 와 b 의 최대 공약수는 b 와 r 의 최대 공약수와 같다
 이과정을 반복하면 최대공약수가 나온다
 ex) Day4_2



배열
 유형이 같은 여려값들을 저장하기 위한 저장공간의 묶음
 각각의 저장공간은 원소라 하며 원소들은 인덱스를 가지고 인덱스를 통해 접근 가능하다
    ex) int[] num = { 1, 2, 3, 4 };
        sout(num[2]); = sout(3);
 원소의 갯수를 배열의 크기라 한다
 .lenght를 사용해 배열의 크기를 구할 수 있다
 배열의 선언은 []를 사용해 자료형에 붙인다
 같은 자료형의 배열만 참조가능
 배열은 new 연산자로 생성한다 
    ex) int[] num = new int[10];
    int 자료형의 크기가 10인 배열을 생성
    생성과 동시에 초기화 한다면
    ex) int[] num = { 1, 2,...};
    처럼 new를 생략할 수 있고 초기화한 값의 개수로 크기가 결정된다



다차원 배열
 중첩된 배열을 다차원 배열이라 한다
    배열의 원소가 배열인 상태


2차원 배열
 2차원 배열은 행과 열의 구조를 가진 2차원 평면으로 표현한다
    int[][] num = new int [3][10];
    3 = 행  10 = 열
    num[1][3] = 27; 이라는건 1(2)번째 행에서 3(4)번째 원소가 27
 2차원 배열의 크기(각 행의 원소의 갯수)는 각각의 크기를 가진다



메서드
 어떤 특정 코드를 수행하는 프로그램
 한번 작성하면 필요할때마다 호출해서 사용가능
 메서드는 객체의 기능을 나태낸다
 객체에 포함된 함수를 메서드 라고 한다
 새로운 메서드를 만드는 것을 정의 라고한다

 메서드의 구조
    접근제어지시자 반환값의자료형 식별자(매개변수목록)
    {
        메서드 본체({안에 작성})
        return 반환값;
    }

    public int add(int x, int y){
        return x + y;
    }

메서드의 반환 값
 메서드가 정상적으로 종료되는 상황에는 2가지가 있다
 본체끝에 도달했을때, return문을 만날때
 이때 return 문을 만나 반환되는 값을 반환값이라하며 return문 뒤에 작성하며
 메서드의 반환값이 없다면 void 자료형으로 하고 이때 return 문은 생략 가능하다



객체 지향 프로그램
 데이터와 절차를 하나의 덩어리로 묶어서 생각하는 방법
 캡슐화, 상속, 다형성 등을 통해 코드의 관리와 유지 보수가 쉬워진다
 특징으론 자료추상화, 상속, 다형성 등이 있다

    자료추상화
     특정대상을 표현하는 여러 값과 기능을 하나로 묶어서 정리한 것
     캡슐화를 통해 외부로부터 객테의 정보흫 숨길수 있다

    상속
     이전에 작성한 클래스를 이어 받아 새로운 클래스를 생성하는 기법
     기존의 코드를 재활용하기 위한 방법

    다형성
     이름 하나로 여러 상황에 대처하는 기법
     개념적으로 동일한 작업을 하는 메서드들에 같은 이읆을 부여할 수 있으므로 코드가 더 간단해 진다
    

클래스와 객체
            
    클래스
     객체를 만들기 위한 자료형
     어떤 클래스로 생성한 객체를 그클래스의 인스턴스 라고 한다

    객체
     특정 대상을 프로그램으로 구현해놓은것
     자료형이 클래스인 자료형을 객체라 한다  
     자료와 기능이 집한한 형태
    
    구조 
        클래스 정의
        {
            필드
            
            메서드
        }

        ex)
        class Car {
            String color;
            int speed;
            int gear;

            void print() {
                sout("Color: " + color);
                sout("Speed: " + speed);
                sout("Gear: " + gear);
        }

     해당 클래스를 생성시 이후 객체를 생성하는데
     참조하며 새로운 참조 변수를 선언하는법의 예 이며
     Car mycar = new Car(); 
     형태를 가지며 생성자를 통해 새로운 인스턴스를 생성한다
     이후 참조 변수의 식별자를 통해 접근 가능하다


캡슐화와 정보 은닉
    
    캡슐화
     객체 지향 프로그램에서는 관련있는 데이터와 기능을 묶어 하나의 블랙박스를 생성하는데 이를 캡슐화 라 한다
     이때, 객체는 독립적으로 완벽한 역할을 수행할 수 있어야 한다
     객체를 사용하는 개발자는 객체의 정보와 기능을 활용할 수 있는 인터페이스만 알면되며, 내부 동작은 알 필요가 없다

    정보 은닉의 필요성
     의도치 않게 외부에서 접근해서 객체가 가지고 있는 데이터를 오염시킬 수 있다
     그로 인해 오류가 발생하는 걸 방지 하기 위해, 객체가 가지고 있는 정보를 외부에서는 보이지 않게 숨긴다
     이를 위해 클래스에서 필드는 일반적으로 private 멤버로 선언한다


필드와 변수

    필드
     클래스에서 정의한 멤버변수
     각 인스턴스의 개별적인 저장공간이 지정
     인스턴스 마다 다른 값을 저장

    지역변수
     메서드나 블록 안에서 선언한 변수

    매개변수
     메서드에 전달되는 값을 저장하기 위한 변수



설정자와 접근자
    
    설정자
     객체가 가진 값을 보호하기 위해 일반적으로 필드는 private 멤버로 선언한다
     쉽게 말해 해당 클래스의 객체를 가진 변수의 값을 지정
          

    접근자
     객체가 가진 값에 접근하기위해 우회해서 접근
     값을 지정하기위해 클래스안에 있는 멤버 변수를 직접 접근할수 없어 우회해서 접근


메서드 오버로딩
 같은 식별자를 가진 객체를 가질수 있으며 오버로딩을 하기 위해선 매개 변수의 
 자료형, 갯수등의 차이가 있아야 오버로딩이 가능하다
 예를 들면 int 형 자료형과 char 자료형을 가진 각각의 num 식별자를 가진 객체가 존재할수있고
 입력하는 값릐 자료형에 따라 해당하는 객체가 호출되서 실행된다



this 참조변수와 this 메서드

    this 참조변수
     생성자와 설정자의 매개변수를 지정할시 해당 매개변수가 어떤 변수를 의미하는지 모르기때문에 일일이 지정해줘야 하지만
     this 참조 변수를 사용하면 메서드에 접근하고 있는 객체 자신을 참조할수 있다
     그렇게 되면 같은 변수의 이름을 쓰더라도 this 참조변수로 인해 다른 변수로 지정된다

    this 메서드
     생성자에서 다른 생성자를 호출하기 위한 메서드
     this 메서드는 생성자의 첫번째 문장에서만 호출할 수 있다
     주어진 인자의 자료형과 갯수에 따라 어떤 생성자가 호출될지 결정된다



생성자

    기본생성자
     클래스에 생성자가 없더라도 객체는 생성되어야 하므로 컴파일러가 추가하는 추가 생성자
     클래스에 생성자가 있으면 기본 생성자는 추가 되지 않음
     
    복사생성자
     다른 객체의 값을 그대로 복사해서 새 객체 생성
     문법이 따로 있는 건 아니고, 직접 만들어 사용함



정적 변수와 정적 메서드
 
    정적 멤버란
     클래스에서 static 키워드를 붙여 정의한 멤버
     정적 멤버는 클래스에서 정의한 멤버지만 객체에 속한 멤버는 아니다
     클래스당 하나씩 생성된다
     정적멤버는 main 메서드가 호출되기 전에 저장공간이 할당되고 초기화 되기에 객체 생성과 상관없이 사용할 수 있다

    정적 변수

        인스턴스변수
         객체마자 하나씩 있는변수
         객테의 일반적인 필드

        정적 변수
         프로그램 전체에서 하나만 존재
         클래스의 모든 인스턴스가 공유하는 필드
         그래서 정적변수는 클래스 변수라고도 한다
         해당 변수에 접근하려면 클래스의 식별자로 접근해야한다
            Sample num = new Sample(10);
            
            n = num.정적변수 = X
            n = Sample.정적변수 = O

         객체의 생성과 상관없이 먼저 저장공간이 할당되며 초기화 된다
         그러므로 생성자에서 초기화 할 수 없어서 미리 초기화 해야한다
         
    
    정적 메서드
     static 키워드를 붙여 선언한 메서드
     정적 변수는 프로그램이 싱행되자마자 main 메서드가 호출되이 이전에 저장공간이 할당되고 초기화된다
     그래서 객체가 생성되기 전에 접근이 가능하다
     정적 메서드는 객체가 생성되지 않아도 호출할 수 있기 때문에 객테의 일반 필드나 메서드에 접근 할 수 없다
     정적 메서드를 호출하는 시점에 객테가 생성되지 않았을 수도 있기에 
     정적 메서드에서는 객체 자신을 참조 하는 this 참조 변수를 쓸 수 없다
    
    정적 메서드의 재정의
     정적 메서드는 객체가 아닌 클래스에 속한 멤버이다
     정적 메서드는 정적 바인딩을 하기 때문에 메서드의 식별자가 슈퍼 클래스 메서드와 같다고 
     해도 별개의 메서드지 재정의하는것이 아니다
     따라서 @Override 주해를 붙일 수 있다

    정적 상수
     상수 필드가 모든 인스턴스에서 같은 값을 가지면 저장공간을 절약하기 위해 정적 변수로 선언한다
        static final int MAX = 100;
     해당 변수는 static 이 아닌 public 으로 선언해도 값이 변하지 않기때문에 상관 없다
     

객체 배열
 배열의 각각의 원소들이 객체를 참조하는 참조변수이다
 객체 배열의 원소는 객체를 생성해서 각 원소로 참조한다


열거형
 어떤 값을 나타내는 여러 상수들의 묶음을 만들기 위한 자료형
 클래스의 일종이며, enum 키워드를 통해 정의
    열거형을 정의할 때는 열거형 상수들을 나열한다
 열거형 상수는 내부적으로 정적 상수로 생성된다

열거형 변수
 열거형은 클래스의 일종이므로, 자료형이 열거형인 참조변수를 선언해 열거형 상수를 대입한다
 열거형 상수는 정적 변수이므로, 열거형 식별자로 접근한다
     


클래스 정의 절차와 UML

    클래스 정의 절차
     대상선택 -> 속성 설정(필드) -> 기능 설정(메서드)

    UML
     소프트웨어 공학에서 사용되는 표준화된 범용 모델링 언어



메서드 체이닝
 메서드를 고리처럼 연결해 연속해서 호출하는 방식
 알아야하는점은 호출하기 위해선 앞선 호출식에서 자신을 반환하고 자료형을 클래스명으로 바꿔줘야 한다



상속
 상속하는 클래스는 슈퍼 클래스라하고
 받는 클래스를 서브 클래스라 한다
 중복되는 클래스를 하나로 묶어 상속시킨다


서브 클래스의 인스턴스
 서브 클래스의 인스턴스는 슈퍼 클래스의 인스턴스를 포함하는 형태로 생성된다

종단 클래스와 메서드
 final 이란 키워드가 붙으면 상속이나 재정의를 할 수 없다

instanceof 사용
 첫번째 해당 클래스가 두번째 클래스의 참조되는지 확인 참조되었다면 참 아니면 거짓이 나온다


정적 바인딩
 컴파일 단계에서 참조변수의 자료형에 따라 어떤 메서드를 호출할지 결정한다
 일반 메서드와 정적 메서드는 정적 바인딩을 한다


동적 바인딩
 프로그램 실행단게에서 참조 변수가 참조하는 객체의 자료형에 따라 어떤 메서드를 호출할지 결정한다
 재정의한 일반 메서드는 동적 바인딩을 한다
 


추상 클래스와 인터페이스

추상 클래스
 클래스 중 오로지 상속을 위한 클래스를 위해 인스턴스의 생성을 막기위해 추상 메서드로 정의함
 정의가 없고 선언만 되어있는 클래스
 abstract 키워드를 붙인며 메서드 원형뒤에 ; 를 붙인다
 추상클래스는 객체로 생성할 수 없다
 슈퍼 클래스에서 정의하줘야한다


인터페이스
 일종의 추상클래스이며 추상 클래스보다 추상화 정도가 높다
 interface 키워드를 사용한다
 추상 메서드와 정적 메서드만 사용가능하며 모든 멤버는 public 멤버여야만 한다
 미리 정해진 규칙에 맞게 클래스를 구현하도혹 도와준다
 해당 클래스를 상속하는걸 구현한다라고 하며 implements 로 구현시킨다
 


예외 처리
 예외
 프로그램이 실행중 발생하는 어떤 상황
 컴파일 단계에 오류는 포하함하지 않는다

 나눗셈의 제수가 0
 배열의 인덱스가 한계를 넘는상황
 등등

    try - catch 구문
    try - with - resources 구문

예외의 종류

 Error - JVM 에서 발생한 오류

 RuntimeException - 프로그래밍 버그, 논리 오류로 인한 오류
   
 기타 예외 - 위의 오류를 제외한 다른 예외는 try - catch 구문으로 처리해야한다


Java 표준 라이브러리의 패키지


    Object 클래스의 인스턴스 메서드
     자바의 모든 클래스가 자동으로 상속받는 최상위 부모 클래스
     별도로 extends 하지 않아도 모든 클래스는 Object의 기능을 기본으로 가짐
     공통적으로 필요한 기본 기능(toString, equals, hashCode 등)을 제공
     자바에서 객체가 가지는 최소한의 동작을 정의하는 클래스

         toString()
          객체를 문자열로 표현하는 메서드.
          객체 출력 및 디버깅에 사용.
         
         equals(Object obj)
          두 객체가 내용적으로 같은지 비교한다.
          문자열 비교, 중복 체크 시 사용.
         
         hashCode()
          객체의 해시 값을 반환한다.
          HashSet, HashMap에서 검색/저장 시 사용.
         
         clone()
          객체를 복사하는 기능.
          Cloneable 인터페이스 필요.
          원본 보존 및 복제 작업에 사용.
    
         finalize()
          객체가 쓰레기 수집기(GC)에 의해 제거되기 직전에 호출
          Java 9부터 Deprecated (사용 비권장)
          자원 해제는 try-with-resources 또는 finally 사용 권장
    
         getClass()
          객체의 클래스 정보를 반환
          실행 중 클래스 타입 확인할 때 사용
          리플렉션(Reflection)에서 활용됨


    String 클래스의 인스턴스
     char 자료형 배열과 그에 관련된 메서드들이 정의 되어 있다
     String 클래스의 인스턴스는 내용을 바꿀 수 없다
        
            StringBuffer 클래스
             가변(Mutable) 문자열을 처리하는 클래스
             모든 주요 메서드가 synchronized 처리되어 스레드 안전(Thread-Safe)
             멀티스레드 환경에서 문자열을 자주 수정하는 경우 적합
             성능은 StringBuilder보다 느리지만 안정성이 중요할 때 사용됨
                
                append()
                 문자열 또는 데이터를 뒤에 추가한다.
                 멀티스레드 환경에서도 안전하게 동작.
                 
                insert(int offset, ...)
                 지정된 위치에 문자열이나 데이터를 삽입한다.
                 
                delete(int start, int end)
                 특정 범위의 문자열을 삭제한다.
                 
                deleteCharAt(int index)
                 해당 위치의 문자를 하나 제거한다.
                 
                reverse()
                 현재 문자열의 순서를 뒤집는다.
                 
                toString()
                 완성된 문자열을 String 객체로 반환한다.
                 
                length()
                 현재 문자열의 길이를 반환한다.
                 
                capacity()
                 내부 버퍼의 총 용량을 반환한다.
                 
                ensureCapacity(int minimumCapacity)
                 최소 용량을 보장하기 위해 내부 버퍼를 확장한다.
                 
                setCharAt(int index, char ch)
                 지정한 위치의 문자를 변경한다.
                 
                charAt(int index)
                 해당 위치의 문자를 반환한다.
                 
                replace(int start, int end, String str)
                 지정된 범위를 새로운 문자열로 대체한다.
                 
                substring(int start, int end)
                 주어진 범위의 문자열을 잘라 String 형태로 반환한다.

            
            StringBuilder 클래스
             가변(Mutable) 문자열을 다루기 위한 클래스
             문자열 수정·추가에 최적화되어 성능이 뛰어남
             스레드 동기화를 제공하지 않아 단일 스레드 환경에 적합
             StringBuffer보다 빠르며, 문자열 변경 작업에 널리 사용됨

                 append()
                  문자열 또는 데이터를 뒤에 추가한다.
                  반복적인 문자열 조립 작업에 사용.
            
                 insert(int offset, ...)
                  지정한 위치에 문자열이나 데이터를 삽입한다.
            
                 delete(int start, int end)
                  주어진 범위의 문자열을 삭제한다.
            
                 deleteCharAt(int index)
                  해당 위치의 한 문자를 제거한다.
            
                 reverse()
                  문자열의 순서를 뒤집는다.
            
                 toString()
                  현재 문자열을 String 객체로 반환한다.
            
                 length()
                  현재 문자열의 길이를 반환한다.
            
                 capacity()
                  내부 버퍼의 총 용량을 반환한다.
                  추가 시 자동 확장의 기준이 됨.
            
                 ensureCapacity(int minimumCapacity)
                  최소 용량을 미리 확보한다.
                  예상되는 큰 문자열 조작 시 성능 최적화에 사용.
            
                 setCharAt(int index, char ch)
                  지정된 위치의 문자를 직접 변경한다.
            
                 charAt(int index)
                  해당 인덱스의 문자를 반환한다.
            
                 replace(int start, int end, String str)
                  특정 범위를 새로운 문자열로 대체한다.
            
                 substring(int start, int end)
                  지정된 범위의 문자열을 잘라 String 형태로 반환한다.
            
            
            
    Math 클래스
     수학 연산을 위한 정적 메서드 제공
     sqrt, pow, abs, random 등 다양한 연산 포함
    
    
    class 클래스
     모든 클래스의 메타정보를 담는 클래스
     리플렉션을 통해 필드, 메서드, 생성자 정보를 얻을 수 있음
    
    
    System 클래스
     시스템 자원 접근을 위한 정적 메서드 제공
     in, out, err 스트림 및 gc, currentTimeMillis 등 기능 제공
    
    
    래퍼 클래스
     기본형 자료형을 객체로 다루기 위한 클래스
     Integer, Double, Character 등 기본형을 감싸는 역할
    
    
    레퍼 클래스의 오토 박싱
     기본형 → 래퍼 객체로 자동 변환되는 기능
     
    
    integer 클래스의 정적 메서드
     parseInt, valueOf 등 문자열 숫자 변환 지원 

    


java.util 패키지

    Arrays 클래스
     배열 관련 정적 메서드 제공
     sort, binarySearch, copyOf 등 포함
    
    Objects 클래스
     객체 비교, 널 체크 등을 위한 유틸 메서드 제공
     
    Random 클래스
     난수 생성 기능 제공
     다양한 기본형 타입에 대한 난수 생성 가능
    
    Scanner 클래스
     입력을 처리하기 위한 클래스
     문자열, 숫자 등 다양한 타입으로 입력 변환 가능
    
    StringTokenizer 클래스
     문자열을 토큰 단위로 분리하는 기능
     구분자 기반 문자열 처리에 사용됨

    

제네릭 프로그래밍
 다양한 자료형을 가지는 객체들을 동일한 코드로 처리하는 기법
 인터페이스와 클래스를 생성하기 위한 틀 이다
 제네릭 컬렉션 프레임워크에서 많이 사용한다

    제네릭 클래스
     원하는 클래스에 <> 를 사용해 지정가능 
     <> 안에는 타입 매개 변수가 들어가고 , 로 구분하여 넣을 수 있다
         E - Element
         K - Key
         T - Type
         N _ Number
         V _ Value
         S ,U, V - 두번째 세번째 네번째 변수
 
    제네릭 메서드
     public static <T> T get...(T[] a)
     메서드에서 매개변수까지 타입 매개 변수로 지정하면 대입하는 자료형에따라 바뀐다
     또한 자료형을 제한시킬 수 있으며 


    와일드 카드
     ? 는 와일드 카드라 브르며 어떤 자료형이든지 나타낼 수 있다



컬렉션
java에서 자료 구조를 구현한 인터페이스들과 클래스들
자료구조로는 리스트, 스택, 큐, 집합, 해시 테이블 등이 있다


컬렉션 인터페이스 종류

    Collection<E> 인터페이스의 기본 연산
        size() - 요소들의 개수 반환
        isEmpty() - 컬렉션 객체가 비어있는지 검사
        contains(Object obj) - 요소들 중 obj가 포함되어있는지 검사
        add(E element) - 요소를 컬렉션에 추가
        remove(Object obj) - 해당 요소를 제거
        iterator() - 요소들을 순회하기 위한 반복자 반환
        forEach(Consumer<T> action) - 모든 요소에 대해 지정된 작업 실행


    Collection<E> 인터페이스의 벌크 연산
        addAll - 다른 컬렉션의 모든 요소를 추가
        containsAll - 다른 컬렉션의 모든 요소가 포함되어 있는지 검사
        removeAll - 다른 컬렉션에 포함된 요소들을 모두 제거
        removeIf - 조건에 맞는 요소들을 일괄 제거
        retainAll - 지정한 컬렉션에 포함된 요소들만 남기고 나머지 제거
        clear() - 모든 요소들을 제거
        

    Collection<E> 인터페이스의 배열 연산
        toArray() - 컬렉션 요소들을 Object 배열로 변환
        toArray(T[] a) - 지정한 타입의 배열로 변환하여 반환


    Collection<E> 인터페이스의 기타 연산
        stream() - 스트림 API 사용을 위한 스트림 반환
        parallelStream() - 병렬 스트림 반환


    List<E>
     배열처럼 요소들이 순서대로 나열되어있는 구조
     (배열과 다르게 크기가 자동으로 관리됨)
     중복된 요소를 허용하며 저장순서가 유지된다
     ArrayList<E>, LinkedList<E>, Vector<E>, Stack<E>
     들이 해당 인터페이스를 구현한 클래스 이다
    
            ArrayList<E> - 내부 구조가 배열이며 조회가 빠름

            LinkedList<E> - 노드들이 연결된 형태로 삽입·삭제가 빠름
            
        
    Map<K, V>
     키(key)와 값(value) 쌍으로 구성된 구조
     키는 중복될 수 없고, 값은 중복 가능
     해시맵, 트리맵, 링크드해시맵 등이 대표적인 구현체
     

    Set<E>
     중복을 허용하지 않는 집합 구조
     저장 순서를 유지하지 않는 경우가 많음
     HashSet, LinkedHashSet, TreeSet 등이 구현체
     

    Queue<E>
     선입선출(FIFO) 특성을 가진 선형 자료 구조
     자료를 입력하는 곳과 출력하는 곳이 다르다
     자료 추가·삭제는 빠르지만 중간 요소 접근이 어렵다
     순서대로 처리해야 하는 작업에 사용
     LinkedList, ArrayDeque, PriorityQueue 등이 구현체
        

    Stack<E>
     후입선출(LIFO) 구조
     가장 마지막에 넣은 자료가 먼저 나오는 형태
     push, pop 연산 제공
     Vector 기반 Stack 클래스는 사용 권장X → 대신 Deque 사용 권장

    
    Deque<E>
    

Collections 클래스

    Collections 클래스의 정적 메서드
        addAll - 여러 요소를 한 번에 컬렉션에 추가
        binarySearch - 정렬된 리스트에서 이진 탐색 수행
        sort - 리스트를 정렬
        reverse - 요소들의 순서를 반대로 변경
        shuffle - 요소들을 무작위로 섞음
        max - 최대값 반환
        min - 최소값 반환
        fill - 리스트를 동일한 값으로 채움

            

정적 팩토리 메서드 패턴
 정적 메서드를 통해 간접적으로 객체를 생성하는 디자인 패턴
 생성자 대신 의미있는 이름을 가진 정적 팩토리 메서드를 사용해서 코드의 가독성을 높인다
 정적 펙토리 메서드를 사용해서 객체 생성 로직을 캡슐화할 수 있다
 객체 생성 비용이 크거나 동일한 객체가 자주 요청되는 경우,
 생성된 객체를 캐싱해서 재사용할 수 있다
 이는 성능을 크게 향상 시키고 메모리 사용을 최적화할 수 있다


정적 팩토리 메서드
 객체를 생성해서 반환하는 정적 메서드(클래스 메서드)
 생성자 대신 해당 메서드를 사용하는 주된 이유는 메서드에 의이 밌는 이름을 부여해 가독성을 높이고,
 객체를 생성할 때 더 유연하게 제어하기 위해서이다
 

    정적 펙토리 메서드 종류

    from - 자료형이 다른 객체를 전달받아, 이를 변환해서 새로운 객체를 생성해서 반환
    of - 여러 인자를 전달 받아 객체를 생성해서 반환
    valueOf - 특정값으로 객체를 생성해서 반환
    getInstance - 싱글톤 패턴 등에서 인스턴스를 생성해서 반환하거나 이전에 생성한 인스턴스를 반환
    newInstance - 새로운 인스턴스를 생성해서 반환



Java Record
 데이터를 간결하게 preview로 처음 공개 됐고 Java 16에서 정식으로 도입됨
 레코드로 불변 데이터 객체를 생성할 수 있다
 이는 상태를 변경할 수 없어 안정성이 높고 무결성을 유자하며 가독성을 높이고 유지 보수가 쉬워진다
 record 로 선언한다
    public record Point(int x, int y) { }
    () 안에 선언되는 변수는 필드 이며 final로 선언된다 
 record는 상속 받을 수 없지만 인터페이스틑 구형할 수 있다
 record는 선언시 메서드들과 같이 선언되며 따로 직좁 정의한 메서드는 생성되지 않고
 record 생성과 동시에 상수 필드가 생성되기에 생성자에서 초기화 시켜야한다

 record에서 생성자를 간결하게 정의하는 방식을 컴펙트 생성자 라 한다
 주로 매개 변수를 검증하거나 값을 정규화 하기위해 사용한다

 record의 필드는 private 멤버로 선언되므로 접근자를 통해 참조해야한다
 생성과 동시에 접근자도 같니 생성되지만 해당 접근자는 get을 사용하는것이 아닌 필드의 자료형으로 선언된다
 특별한 이유가 아니라면 자동으로 추가되는 메서드를 사용한다



내부 클래스
 내부에서 정의한 클래스
 클래스 내부에서 정의하는것만 빼면 일반적인 클래스와 같다
 해당 클래스는 두 클래스가 긴밀한 관계에 있거나, 어떤 클래스나 메서드에서만 사용하는 클래스인 경우에 사용
 내부 클래스는 4가지 종류가 있다
 인스턴스, 정적, 지역, 익명

 static 안 붙으면 인스턴스 붙으면 정적

 메서드 본체에 정의하면 지역 
 
 식별자를 지정하지 않으면 익명 



빌더 패턴
 생성자를 사용하지 않고 객체를 생성
 객체의 생성과정과 표현방법을 분리해 다양한 인스턴스를 생성
 생성자에 들어갈 매개 변수를 메서드로 하나씩 받아들이고 마지막에 빌드해서 인스턴스를 생성
 클래스에 필드가 많거나 생성자에 선택적 매개 변수가 많은 상황에서 유용하다

    public class Person {
    private String name;
    private int age;
    private String email;

        // Builder Class
        public static class Builder {
            private String name;
            private int age;
            private String email;
    
            public Builder name(String name) {
                this.name = name;
                return this;
            }
            public Builder age(int age) {
                this.age = age;
                return this;
            }
            public Builder email(String email) {
                this.email = email;
                return this;
            }
    
            public Person build() {
                return new Person(this);
            }
        }
    
        private Person(Builder builder) {
            this.name = builder.name;
            this.age = builder.age;
            this.email = builder.email;
        }
    
        @Override
        public String toString() {
            return name + ", " + age + ", " + email;
        }
    }

    위에 클래스를 바탕으로 사용한 예시

    public class Main {
    public static void main(String[] args) {
        Person p = new Person.Builder()
                        .name("홍길동")
                        .age(25)
                        .email("hong@test.com")
                        .build();

        System.out.println(p);
    }
}



명령형 프로그래밍
 문제를 어떻게 해결할 것인지 설명하는 방식
 주로 할당이나 제어문에 신경을 쓴다
 이론적 배경은 튜링 머신이다
종류
 절차 지향 프로그래밍
 객체 지향 프로그래밍


선언형 프로그래밍
 무엇을 할것인지 어떻게 할것인지 설명하는 방식
 내부 구현 방법은 주로 라이브어리가 결정한다
 이론적 배경은 람다 대수이다
종류
 함수형 프로그래밍



함수형 프로그래밍
 순수 함수를 조합해 프로그램을 만드는 방식 
 불변성을 가지며 복사본을 만들어 작업하는 원칙이 있다
 1급 객체 함수를 값으로 취급해서 변수에 할당하거나 다른 함수의 인자로 전달하거나 반환값으로 사용할 수 있다
 고차 함수 다른 함수를 인자로 받거나 반환 값으로 내놓는 함수를 의미한다
 익명 함수 이름이 없는 함수이다
 참조 투명성 함수 호출을 해당 함수의 결과 값으로 대체할 수 있다
 
장점
 예측 가능성 및 테스트 용이
 병렬 처리 효율성
 코드 품질 향상
 재사용성


부수 효과와 순수 함수

부수 효과
 다음과 같은 변화 또는 변화가 발생하는 작업을 의미한다
 자료 구조나 변수, 객체 필드의 값이 변경됨
 예외나 오류가 발생하며 실행이 중단됨
 콘솔 입출력 또는 파일 입출력이 발생함

순수 함수
 부수 효과를 제거하고, 동일한 입력에 대해 항상 동일한 결과를 반환하는 함수
 메모리나 입출력의 관점에서 부수효과가 없는 함수
 함수의 실행이 외부에 영향을 끼치지 않는 함수
 함수가 독립적이고 부수 효과가 없기 때문에 스레드에 안전성을 보장한다
 스레드에 안전성을 보장받아 병렬처리를 동기화 없이 진행 가능


함수형 인터페이스와 람다 표현식
 
함수형 인터페이스
 Object 클래스의 메서드를 제외하고 구현해야할 추상 메서드가 하나만 정의된 인터페이스
 기본 메서드나 정적 메서드는 몇개가 있든 상관없음
 함수형 프로그래밍을 지원하기 위해 Java8 에서 도입됨
    
    // 함수형 인터페이스는 아래와 같은 패키지로 제공된다
    package java.util.function;

    // 함수형 인터페이스는 아래와 같은 주해를 붙인다
    @FunctionalInterface
    public interface Runnable {
        // 둘 이상의 추상 메서드를 선언하면 컴파일 오류가 발생
        public void run();
    }

종류
    Runnable - 매개변수와 반환값이 없는 함수 상태 - () -> void
    Consumer<T> - 매개 변수는 있지만 반환값이 없는 함수 상태 - T -> void
    Supplier<T> - 매개 변수는 없고 반환 값이 있는 함수 상태 - () -> T
    Function<T, R> - 매개변수를 매핑(자료형 변환)해서 반환하는 함수 상태
    Predicate<T> - 매개 변수가 조건에 맞는지 확인해서 반환하는 함수 상태
    Operator<T, T> - 매개 변수를 연산해서 결과를 반환하는 함수 상태





람다 표현식
 메서드를 표현식으로 작성해서 함수 객체를 생성
 메서드를 람다 표현식으로 표현하면 식별자와 반환 값 자료형이 없어지므로 람다 표현식을 익명 함수라고도 함
    (매개 변수 목록) -> {body}
 매개변수 목록은 ()로 묶고 메서드 본체는 {} 로 묶는다
 메서드 본체가 하나면 중괄호와 ; 을 생략할 수 있고, return도 생략 가능
 컴파일러가 인자의 자료형을 통해 자료형을 추론할 수 있기에 매개 변수의 자료형을 생략할 수 있디
    
    int square(int x) { return x * x; };
    Function<Integer, Integer> square = (Integer x) -> { return x * x; };
    Function<Integer, Integer> square = x -> x * x; 로 생략 가능
 
 이런식으로 생략하면 코드에 대한 가독성이 증가하고 간결성또한 증가한다
 또한 클래스를 정의해야하는 과정을 생략해도 된다
 이러한 코드를 작성하기전 함수혈 인터페이스를 통해 먼저 해당하는 인터페이스를 호출해 작성해야한다
 일회성으로 주로 1번만 사룔하거나 함수를 인자로 전달해야 하는 경우에 유용하게 사용한다
 


메서드 레퍼런스
 람다 표현식을 더 간단하게 표형할 수 있다

    Consumer<String> print = text -> System.out.println(text);
    print.accept("Hi");

    람다 표현식중 매개변수가 1개이고 문장이 하나이며 그 메서드에 매개변수가 대입되야한다면

    Consumer<String> print = System.out::println;
    print.accept("Hi");

 네가지 형태

    클래스::정적 메서드
        클래스의 정적 메서드를 표현

    객체::메서드
        생성된 객체의 일반 메서드를 표현

    클래스 식별자::메서드
        클래스의 인스턴스를 그대로 넘겨 그 객체의 메서드를 표현

    클래스 식별자::new
        클래스의 생성자를 표현



Java Stream API
 스크림은 데이터의 연속적인 흐름을 말한다
 Java Stream API는 데이터의 연속적인 흐름을 표준화된 방법으로 쉽게 처리할 수 있도록 지원하는 클래스의 집합이다
 for 구문이나 while 구문을 사용하던 기존 반복문을 대체할 수 있어 코드 가독성이 좋아진다
 병렬 처리를 쉽게 할 수 있어서 처리 속도를 높일 수 있다



재귀 호출
 메서드 본체에서 함수 자신을 다시 호출하는 방식
 반복문 처럼 메서드 본체를 반복적으로 실행할 수 있다
 자주 사용하지는 않지만 특정 알고리즘을 구현하는 데 유용하다


코딩 테스트
 개발자가 어떤 역량을 가졌는지 확인하는 철자
 해당 테스트는 시간 복잡도, 구현방법 등을 고민하며 개발자로써 어떻게 문제를 풀어가는지 확인

시간 복잡도
 시간복잡도는 해당 코드가 실행될때 어떤식으로 시간이 흘러가는지에 대한 지표?
 O() 으로 표기할수 있으며 계산 방법은 3n + 5 + 2 라는건 가장 앞에있는 n의 크기가 터지면 그만큼 시간이 늘어나기에
 O(n)이라 표기할수 있다 n제곱이면 더 늘어나니 n제곱이 들어간다 이런식으로 계산했을때
 O(n log n) 방식이 제일 좋은 시간 복잡도이다
















 



 






